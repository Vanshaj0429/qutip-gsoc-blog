[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to My GSoC 2025 Journey",
    "section": "",
    "text": "Hi, I‚Äôm Vanshaj Bindal ‚Äì a MSc Physics graduate with a passion for quantum information, theoretical physics and newfound interest in open-source development. I‚Äôm thrilled to be participating in Google Summer of Code 2025 with NumFOCUS, working on an exciting project that bridges quantum physics and computational tools.\nThis blog is a record of my GSoC experience, technical discoveries, and the fascinating world of quantum simulation software.\n\n\n\n\n\n\n\n\n\nI‚Äôm developing a comprehensive Hamiltonian Library for QuTiP (Quantum Toolbox in Python), one of the most widely-used quantum simulation frameworks. Currently, QuTiP users must frequently recreate common quantum system Hamiltonians from scratch, leading to redundant work and potential inconsistencies.\nWhat I‚Äôm Building:\n\nReady-to-use implementations of frequently used quantum systems including Jaynes-Cummings, Rabi, Dicke, and various spin-chain models\nA standardized API with JSON serialization for cross-platform compatibility\nTime-dependent parameter support for dynamic quantum systems\n\nLaTeX representation capabilities for clear mathematical documentation\nComprehensive documentation, tutorials, and seamless integration with QuTiP‚Äôs existing functionality\n\nTechnologies & Tools:\n\nPrimary: Python, QuTiP, NumPy, SciPy\nDevelopment: Git, GitHub, Jupyter Notebooks\nDocumentation: LaTeX, Matplotlib\n\nTesting: pytest framework\n\nMentors: Alex Pitchford, Neill Lambert, Eric Giguere and Simon Cross\nThis project will enhance the user experience for quantum researchers and reduce redundancy in quantum simulations.\nüîó View Project Details on GSoC Website\n\n\n\n\n\n\nMay 21st, 2025\nA few months ago, I decided to apply for Google Summer of Code, hoping to contribute to an open-source project that would challenge me and make a real impact‚Ä¶\nRead more ‚Üí\n\n\n\n\nThis site is built with Quarto and hosted on GitHub Pages. It serves as both a technical blog and a documentation of my open-source contributions while doing this project.\nTopics I write about:\n\nQuantum mechanics and simulation\nDifferent quantum systems\nOpen source development\n\nPython programming\nGSoC 2025 journey\nTechnical tutorials and insights\n\n\nLast updated: June 2025"
  },
  {
    "objectID": "index.html#about-the-project",
    "href": "index.html#about-the-project",
    "title": "Welcome to My GSoC 2025 Journey",
    "section": "",
    "text": "I‚Äôm developing a comprehensive Hamiltonian Library for QuTiP (Quantum Toolbox in Python), one of the most widely-used quantum simulation frameworks. Currently, QuTiP users must frequently recreate common quantum system Hamiltonians from scratch, leading to redundant work and potential inconsistencies.\nWhat I‚Äôm Building:\n\nReady-to-use implementations of frequently used quantum systems including Jaynes-Cummings, Rabi, Dicke, and various spin-chain models\nA standardized API with JSON serialization for cross-platform compatibility\nTime-dependent parameter support for dynamic quantum systems\n\nLaTeX representation capabilities for clear mathematical documentation\nComprehensive documentation, tutorials, and seamless integration with QuTiP‚Äôs existing functionality\n\nTechnologies & Tools:\n\nPrimary: Python, QuTiP, NumPy, SciPy\nDevelopment: Git, GitHub, Jupyter Notebooks\nDocumentation: LaTeX, Matplotlib\n\nTesting: pytest framework\n\nMentors: Alex Pitchford, Neill Lambert, Eric Giguere and Simon Cross\nThis project will enhance the user experience for quantum researchers and reduce redundancy in quantum simulations.\nüîó View Project Details on GSoC Website"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Welcome to My GSoC 2025 Journey",
    "section": "",
    "text": "May 21st, 2025\nA few months ago, I decided to apply for Google Summer of Code, hoping to contribute to an open-source project that would challenge me and make a real impact‚Ä¶\nRead more ‚Üí"
  },
  {
    "objectID": "index.html#about-this-site",
    "href": "index.html#about-this-site",
    "title": "Welcome to My GSoC 2025 Journey",
    "section": "",
    "text": "This site is built with Quarto and hosted on GitHub Pages. It serves as both a technical blog and a documentation of my open-source contributions while doing this project.\nTopics I write about:\n\nQuantum mechanics and simulation\nDifferent quantum systems\nOpen source development\n\nPython programming\nGSoC 2025 journey\nTechnical tutorials and insights\n\n\nLast updated: June 2025"
  },
  {
    "objectID": "posts/Week-1/week1.html",
    "href": "posts/Week-1/week1.html",
    "title": "Week 1: Diving Deep into Library Design and the Jaynes-Cummings Model",
    "section": "",
    "text": "The coding phase has officially begun! Week 1 has been a fascinating deep dive into thinking about the design of the Hamiltonian Library and understanding that we‚Äôre building much more than just Hamiltonians, we‚Äôre creating complete quantum systems with collapse operators for Lindblad dynamics. Here‚Äôs what went down in my first week of GSoC 2025."
  },
  {
    "objectID": "posts/Week-1/week1.html#team-meeting-insights-june-3rd",
    "href": "posts/Week-1/week1.html#team-meeting-insights-june-3rd",
    "title": "Week 1: Diving Deep into Library Design and the Jaynes-Cummings Model",
    "section": "Team Meeting Insights (June 3rd)",
    "text": "Team Meeting Insights (June 3rd)\nOur Tuesday meeting with the QuTiP team was incredibly productive, covering several key decisions that will shape the entire project:\n\nBase Class vs.¬†Model Specific Design\nOne of the biggest questions we tackled was whether to create a simple base class for basic Hamiltonian structure or develop model specific base classes. After discussion, we decided on a model specific approach where each quantum system (like Jaynes-Cummings) gets its own class with standardized methods.\nFor example, a Jaynes_Cummings or JCM class would include:\n\n__init__() for parameter initialization\nbuild_hamiltonian() for constructing the quantum operators\nbuild_collapse_operators() for dissipation and decoherence\nto_json() for serialization\nto_latex() for mathematical representation\n\nThe parameters and time dependent parameters would be handled in the __init__ method, while the actual operators, Hamiltonian, and collapse operators are constructed in their respective build methods.\n\n\nBuilding Complete Quantum Systems\nThere was a suggestion made by the mentors that expanded my understanding of the project scope, we‚Äôre not just building isolated Hamiltonians, but complete quantum systems that include:\n\nCoherent dynamics: The Hamiltonian evolution\nIncoherent dynamics: Collapse operators for dissipation, decoherence, and environmental effects\nSystem evolution: Ready to use setups for solving the master equation\n\nThis means each model will provide everything needed to simulate realistic open quantum systems using QuTiP‚Äôs Lindblad master equation solver.\n\n\nThe JSON Serialization Challenge\nThe to_json method emerged as one of the trickier aspects of the project. As noted in our discussion with Neill and Eric, serializing quantum operators and complex mathematical objects isn‚Äôt straightforward. The static data can be represented in a JSON, but it‚Äôs dynamical aspects that seems concerning. Though this is something we decided to tackle when the time comes.\n\n\nFunctions vs.¬†Classes Debate\nWe also discussed whether to use class based structures or simple functions. The consensus was that functions might actually be more user friendly for reusability, users can easily copy and paste function calls and modify parameters as needed. However, I personally feel classes provide better structure for the JSON serialization requirements and managing both Hamiltonians and collapse operators together.\n\n\nRepository Strategy\nFor now, I‚Äôll be starting development in my own repository until we decide whether this becomes part of QuTiP core or remains a separate package. This gives us flexibility to experiment with the architecture."
  },
  {
    "objectID": "posts/Week-1/week1.html#understanding-open-quantum-systems-why-they-matter",
    "href": "posts/Week-1/week1.html#understanding-open-quantum-systems-why-they-matter",
    "title": "Week 1: Diving Deep into Library Design and the Jaynes-Cummings Model",
    "section": "Understanding Open Quantum Systems: Why They Matter",
    "text": "Understanding Open Quantum Systems: Why They Matter\nBefore diving into specific models like Jaynes-Cummings, it‚Äôs helpful to understand a little bit about open quantum systems and why it is important simulating these open systems. Well, all of it comes down to a fundamental reality: real quantum systems are never truly isolated.\n\nThe Idealized vs.¬†Real World\nIn introductory quantum mechanics courses, we often work with closed systems described by the Schr√∂dinger equation:\ni\\hbar \\frac{d|\\psi\\rangle}{dt} = H |\\psi\\rangle\nThis assumes our quantum system exists in perfect isolation, with no external influences. While mathematically elegant, this is rarely realistic. Every quantum system, whether it‚Äôs an atom in a laser field, a qubit in a quantum computer, or photons in an optical cavity, interacts with its environment.\n\n\nWhat Makes a System ‚ÄúOpen‚Äù?\nAn open quantum system is one that exchanges energy, information, or particles with its surroundings. These environmental interactions lead to:\n\nDecoherence: Loss of quantum phase relationships\nDissipation: Energy loss to the environment\n\nNoise: Random fluctuations that affect system dynamics\nIrreversibility: The system‚Äôs evolution becomes non-unitary\n\n\n\nThe Master Equation Approach\nTo handle these effects, we use the Lindblad master equation for the density matrix \\rho:\n\\frac{d\\rho}{dt} = -i[H, \\rho] + \\sum_i \\left(C_i \\rho C_i^\\dagger - \\frac{1}{2}\\{C_i^\\dagger C_i, \\rho\\}\\right)\nHere:\n\nH is the system Hamiltonian\n\\rho is the density matrix of the system\nC_i are collapse operators describing environmental effects\nThe first term gives unitary evolution, the second term adds dissipation\n\n\n\nCommon Types of Environmental Effects\nDifferent quantum systems experience characteristic environmental interactions:\n\nSpontaneous emission: Atoms lose energy by emitting photons\nCavity decay: Photons leak out of imperfect mirrors\nDephasing: Phase relationships decay without energy loss\nThermal noise: Environmental temperature causes random excitations\n1/f noise: Low frequency fluctuations in system parameters\n\nReal experiments always involve environmental effects. A cavity has photon leakage, atoms undergo spontaneous emission, and qubits experience dephasing. Accounting for the right external factors influencing the dynamics of quantum systems is an area of active research. Knowing the right combination of these factors in a give situtation helps modelling and simulating the quantum systems more realistically."
  },
  {
    "objectID": "posts/Week-1/week1.html#getting-to-know-the-jaynes-cummings-model-with-dissipation",
    "href": "posts/Week-1/week1.html#getting-to-know-the-jaynes-cummings-model-with-dissipation",
    "title": "Week 1: Diving Deep into Library Design and the Jaynes-Cummings Model",
    "section": "Getting to Know the Jaynes-Cummings Model (With Dissipation!)",
    "text": "Getting to Know the Jaynes-Cummings Model (With Dissipation!)\nI‚Äôve been diving deep into the complete Jaynes-Cummings system, here is a brief overview.\n\nThe Complete Physics Picture\nThe Jaynes-Cummings model describes the interaction between a two-level atom and a single mode of an electromagnetic field. For the complete open system, we need:\nHamiltonian (Coherent Dynamics):\nH = \\omega_c a^\\dagger a + \\frac{\\omega_a}{2} \\sigma_z + g(a^\\dagger \\sigma_- + a \\sigma_+)\nCollapse Operators (Incoherent Dynamics):\n\nCavity decay: C_1 = \\sqrt{\\kappa (1 + n)} a (photons leak out of the cavity)\nAtomic decay: C_2 = \\sqrt{\\gamma} \\sigma_- (spontaneous emission)\nAtomic dephasing: C_3 = \\sqrt{\\gamma_\\phi} \\sigma_z (pure dephasing without energy loss)\n\nThe master equation becomes:\n\\frac{d\\rho}{dt} = -i[H, \\rho] + \\sum_i \\left(C_i \\rho C_i^\\dagger - \\frac{1}{2}\\{C_i^\\dagger C_i, \\rho\\}\\right)\n\n\nKey Parameters for Complete Systems\nBased on my research and the full system requirements, the key parameters for the JSON ‚Äúrecipe book‚Äù will include:\nCoherent Parameters:\n\n\\omega_c: Cavity frequency\n\\omega_a: Atomic frequency\ng: Coupling strength\n\nIncoherent Parameters:\n\n\\kappa: Cavity decay rate\n\\gamma: Atomic decay rate\n\\gamma_\\phi: Pure dephasing rate\nn: Average thermal photons number\n\nSystem Parameters:\n\nN_{cav}: Cavity dimension (Hilbert space truncation)\nN_{atom}: Atomic levels (usually 2)\n\n\n\nWhy This Matters\nBuilding complete systems rather than isolated Hamiltonians makes the library much more powerful. Researchers can:\n\nGet physically realistic simulations\nStudy decoherence effects and environmental influence\nCompare different dissipation mechanisms\nHave ready to use setups for master equation evolution"
  },
  {
    "objectID": "posts/Week-1/week1.html#technical-tasks-ahead",
    "href": "posts/Week-1/week1.html#technical-tasks-ahead",
    "title": "Week 1: Diving Deep into Library Design and the Jaynes-Cummings Model",
    "section": "Technical Tasks Ahead",
    "text": "Technical Tasks Ahead\nMy immediate tasks for the coming days include:\n\nResearch Phase: Identify five different quantum system models and map out what parameters (both coherent and incoherent) each would need\nPrototype Development: Start with a driven Jaynes-Cummings implementation including both Hamiltonian and collapse operators\nJSON Schema Design: Figure out how to represent complete quantum systems in the parameter ‚Äúrecipe book‚Äù\nMaster Equation Integration: Ensure the output integrates seamlessly with QuTiP‚Äôs mesolve() function\n\nIt seems like a lot more detail needs to be included in these models than previously anticipated, but I think that‚Äôs challenge.\n\nNext week: From theory to code, implementing the first complete Jaynes-Cummings system and tackling the challenge of representing open quantum systems in JSON."
  },
  {
    "objectID": "posts/Week-2/week2.html",
    "href": "posts/Week-2/week2.html",
    "title": "Week 2: Project Pivots, Repository Decisions, and Exploring the Rabi Model",
    "section": "",
    "text": "Week 2 has been all about making crucial project decisions and expanding our understanding of quantum models. From timeline adjustments to repository strategies, plus a deep dive into the Rabi model and its relationship to the Jaynes-Cummings model, this week laid important groundwork for the path ahead."
  },
  {
    "objectID": "posts/Week-2/week2.html#key-project-decisions-june-12th-meeting",
    "href": "posts/Week-2/week2.html#key-project-decisions-june-12th-meeting",
    "title": "Week 2: Project Pivots, Repository Decisions, and Exploring the Rabi Model",
    "section": "Key Project Decisions (June 12th Meeting)",
    "text": "Key Project Decisions (June 12th Meeting)\nOur Thursday meeting with Eric, Alex, Neill, and myself covered several pivotal decisions that will shape the project‚Äôs trajectory:\n\nTimeline Extension Request\nOne of the most significant developments was the decision to request a timeline extension from 12 to 16 weeks. Alex will be reaching out to NumFOCUS to make this request official. This extension is particularly valuable given that I have summer schools scheduled for June 15-20 and August 18-September 5, which will impact my availability during those periods.\nThe extra 4 weeks will allow for:\n\nMore thorough development and testing of the quantum systems library\nBetter integration with QuTiP core\nComprehensive documentation and examples\nBuffer time for unexpected challenges (like the JSON serialization complexities we discussed)\n\n\n\nJSON Format: Parking the Complexity\nAfter extensive discussion, the team decided to park the agnostic format (JSON) requirement for now. As noted in the meeting, ‚Äúnot everyone is convinced of the value for this‚Äù and ‚Äúit is not necessary to get started.‚Äù This is actually a relief, it allows us to focus on building solid, functional quantum systems first, and we can always add serialization capabilities later if there‚Äôs demand.\nThis decision simplifies the immediate development path significantly and lets us concentrate on the core physics and software architecture.\n\n\nRepository Strategy: Staying in QuTiP Core\nEric raised an important concern about separate repositories potentially not being maintained long term. The solution? We‚Äôll develop directly in QuTiP core, within a new quantum_systems folder. Eric will create a development branch called dev.qsystem, and I‚Äôll be pushing commits and PRs to this branch for testing and review.\nThis approach has several advantages:\n\nEnsures long term maintenance and integration\nMakes collaboration with the QuTiP team seamless\nProvides immediate access to QuTiP‚Äôs existing infrastructure\nFacilitates testing with the broader QuTiP ecosystem\n\n\n\nDesign Philosophy: Functions Creating Objects\nThe architectural direction became clearer this week. The main module will contain functions that create structured objects for quantum systems. I‚Äôll be sharing a Jaynes-Cummings example for team review, which will serve as the template for other quantum models.\nThis function based approach strikes a nice balance between usability and structure, users get simple function calls, but the underlying system maintains proper object-oriented design for extensibility."
  },
  {
    "objectID": "posts/Week-2/week2.html#exploring-the-rabi-model-beyond-the-rotating-wave-approximation",
    "href": "posts/Week-2/week2.html#exploring-the-rabi-model-beyond-the-rotating-wave-approximation",
    "title": "Week 2: Project Pivots, Repository Decisions, and Exploring the Rabi Model",
    "section": "Exploring the Rabi Model: Beyond the Rotating Wave Approximation",
    "text": "Exploring the Rabi Model: Beyond the Rotating Wave Approximation\nWhile working on the Jaynes-Cummings implementation, I‚Äôve been diving deep into the Rabi model, which provides fascinating insights into the fundamental atom-field interaction without approximations.\n\nThe Physics Connection\nThe Rabi model is essentially the ‚Äúparent‚Äù of the Jaynes-Cummings model. Where JCM uses the rotating wave approximation to simplify the math, the Rabi model keeps all terms in the interaction:\nRabi Model Hamiltonian: H_{Rabi} = \\omega_c a^\\dagger a + \\frac{\\omega_a}{2} \\sigma_z + g(a^\\dagger + a)(\\sigma_+ + \\sigma_-)\nJaynes-Cummings Model (with RWA): H_{JC} = \\omega_c a^\\dagger a + \\frac{\\omega_a}{2} \\sigma_z + g(a^\\dagger \\sigma_- + a \\sigma_+)\nThe key difference is that the Rabi model includes the ‚Äúcounter-rotating‚Äù terms a^\\dagger \\sigma_+ and a \\sigma_-, which represent processes that don‚Äôt conserve energy (creating a photon while exciting the atom, or destroying a photon while de-exciting the atom).\n\n\nWhen Does the Difference Matter?\nThe rotating wave approximation is valid when g \\ll \\omega_c, \\omega_a, meaning the coupling is much weaker than the characteristic frequencies. But in several important scenarios, the Rabi model becomes essential:\n\nStrong Coupling Regime: When g approaches \\omega_c or \\omega_a\nCircuit QED: Superconducting qubits in microwave cavities often reach strong coupling\nUltrastrong Coupling: Some systems achieve g/\\omega &gt; 0.1, where the RWA completely breaks down\n\n\n\nCollapse Operators for the Rabi Model\nFor the complete open system description, the Rabi model uses the same dissipation mechanisms as JCM:\n\nCavity decay: C_1 = \\sqrt{\\kappa (1 + n)} a\nAtomic decay: C_2 = \\sqrt{\\gamma} \\sigma_-\nAtomic dephasing: C_3 = \\sqrt{\\gamma_\\phi} \\sigma_z\n\nThe master equation structure remains the same, but the Hamiltonian evolution includes the additional oscillating terms that can lead to richer dynamics.\n\n\nImplementation Considerations\nIncluding both Rabi and Jaynes-Cummings models in our library provides users with:\n\nJCM: Fast, well understood dynamics for weak coupling\nRabi: Accurate physics for strong coupling regimes\nEducational value: Direct comparison of approximations vs exact models\nResearch flexibility: Users can easily switch between models\n\nThe parameter sets are nearly identical, making it easy to implement both and let users choose based on their specific regime of interest."
  },
  {
    "objectID": "posts/Week-2/week2.html#development-progress-and-next-steps",
    "href": "posts/Week-2/week2.html#development-progress-and-next-steps",
    "title": "Week 2: Project Pivots, Repository Decisions, and Exploring the Rabi Model",
    "section": "Development Progress and Next Steps",
    "text": "Development Progress and Next Steps\nThis week‚Äôs practical work included:\n\nSetting up the development environment for working with QuTiP core\nBeginning the Jaynes-Cummings implementation that will serve as our template\nResearching the Rabi model as our second quantum system\n\nWeek 3: I am in Paris for a summer school so will not be working actively on the project.\n\nWeek 4 Goals\nThe coming week will focus on:\n\nGetting the development branch set up and testing the workflow\nFinalizing the Jaynes-Cummings implementation\nStarting the Rabi model implementation\nCreating clear documentation and examples\nTesting integration with QuTiP‚Äôs existing functionality"
  },
  {
    "objectID": "posts/Week-2/week2.html#reflections",
    "href": "posts/Week-2/week2.html#reflections",
    "title": "Week 2: Project Pivots, Repository Decisions, and Exploring the Rabi Model",
    "section": "Reflections",
    "text": "Reflections\nThis week felt like a turning point where the project crystallized from abstract planning into concrete development. The decision to park JSON serialization removes a major complexity, while the timeline extension provides breathing room for quality implementation.\nThe repository decision to stay within QuTiP core is particularly exciting, it means our work will have immediate access to the full QuTiP ecosystem and a clear path to long term maintenance.\nDiving into the Rabi model has also been intellectually rewarding. Understanding how it relates to the Jaynes-Cummings model provides a perfect example of why having a comprehensive quantum systems library matters, researchers need easy access to both approximate and exact models depending on their specific use case.\n\nNext week: Branch setup, first PR submissions, and implementing the Rabi model alongside our JCM template."
  },
  {
    "objectID": "posts/intro/gsoc-2025-selection.html",
    "href": "posts/intro/gsoc-2025-selection.html",
    "title": "Exciting News: I‚Äôm Joining Google Summer of Code 2025!",
    "section": "",
    "text": "A few months ago, I decided to apply for Google Summer of Code, hoping to contribute to an open-source project that would challenge me and make a real impact. After weeks of anticipation‚Ä¶\nI‚Äôm thrilled to announce that I‚Äôve been selected as a Google Summer of Code 2025 contributor! üöÄ"
  },
  {
    "objectID": "posts/intro/gsoc-2025-selection.html#what-ill-be-working-on",
    "href": "posts/intro/gsoc-2025-selection.html#what-ill-be-working-on",
    "title": "Exciting News: I‚Äôm Joining Google Summer of Code 2025!",
    "section": "What I‚Äôll Be Working On",
    "text": "What I‚Äôll Be Working On\nHere‚Äôs the problem I‚Äôm helping to solve: currently, QuTiP users often need to recreate common quantum system Hamiltonians from scratch, leading to duplicated effort and potential inconsistencies. My project aims to change that by creating a comprehensive library of ready-to-use implementations.\nThe project will include:\n\nReady-to-use quantum system models (Jaynes-Cummings, Rabi, Dicke, and various spin-chain models)\nStandardized APIs for consistency across different quantum models\nJSON serialization for cross-platform compatibility\nTime-dependent parameter support for dynamic quantum systems\nLaTeX representation for clear mathematical documentation\n\nThis will essentially provide researchers with a well-tested, standardized toolkit for quantum simulations, reducing redundant work and improving consistency across the field."
  },
  {
    "objectID": "posts/intro/gsoc-2025-selection.html#looking-forward",
    "href": "posts/intro/gsoc-2025-selection.html#looking-forward",
    "title": "Exciting News: I‚Äôm Joining Google Summer of Code 2025!",
    "section": "Looking Forward",
    "text": "Looking Forward\nI‚Äôm genuinely excited about this opportunity. The selection process was competitive, and I‚Äôm grateful to have been chosen to work on something that will directly benefit the quantum computing and physics research community.\nWhen I first submitted my application, I knew it was a long shot ‚Äì but I‚Äôm glad I took the chance. Now I get to spend the summer contributing to open-source software that actual researchers will use in their work.\nOver the next few months, I‚Äôll be:\n\nDeveloping and testing the core Hamiltonian library components\nLearning deeper aspects of quantum mechanics and numerical methods\nContributing to a project that will be used by researchers worldwide\nDocumenting the entire development process right here on this blog\n\nYou can expect regular updates including technical insights about quantum computing and library development, challenges and solutions encountered during the project, code examples and implementation details, and reflections on contributing to open-source scientific software.\nThis summer promises to be an exciting blend of learning, coding, and contributing to the quantum computing community. Stay tuned!"
  },
  {
    "objectID": "posts/intro/gsoc-2025-selection.html#acknowledgments",
    "href": "posts/intro/gsoc-2025-selection.html#acknowledgments",
    "title": "Exciting News: I‚Äôm Joining Google Summer of Code 2025!",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nI want to thank the QuTiP team for this incredible opportunity. The mentorship and support they‚Äôve already provided has been exceptional, and I‚Äôm looking forward to working closely with them throughout the summer.\n\nIf you‚Äôre interested in quantum computing, open-source development, or just want to follow along with my GSoC journey, feel free to connect. And if you‚Äôre a fellow GSoC participant this year, I‚Äôd love to hear about your projects too!\n\n\n\n\n\n\nInterested in QuTiP?\n\n\n\nCheck out the QuTiP documentation to learn more about quantum simulations in Python!\n\n\nTags: GSoC2025, QuantumComputing, OpenSource, Python, QuTiP, NumFOCUS,"
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html",
    "href": "posts/Community Bonding/community-bonding.html",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "",
    "text": "The community bonding period (May 10 - June 1) has almost officially wrapped up! This three-week phase was all about getting acquainted with the QuTiP community, understanding the project scope better, and laying the groundwork for a successful summer of coding."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#first-impressions-and-learning-from-the-past",
    "href": "posts/Community Bonding/community-bonding.html#first-impressions-and-learning-from-the-past",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "First Impressions and Learning from the Past",
    "text": "First Impressions and Learning from the Past\nOne of the first things I did was reach out to previous GSoC participants to understand what makes a successful project. Reading through their blogs and briefly examining their contributions gave me valuable insights into the scope and expectations of GSoC projects. It was fascinating to see how different contributors approached their projects, documented their progress, and overcame challenges along the way.\nThe variety of projects from previous years - from quantum machine learning optimization to enhancing quantum circuit diagrams - really highlighted the breadth of impact that GSoC projects can have in the scientific computing community."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#revisiting-my-foundation",
    "href": "posts/Community Bonding/community-bonding.html#revisiting-my-foundation",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "Revisiting My Foundation",
    "text": "Revisiting My Foundation\nI spent considerable time revisiting and refining my original proposal for the Hamiltonian Library. Having been accepted, I wanted to ensure I had a crystal-clear understanding of every aspect of what I committed to deliver. This deep dive helped me identify some of the challenges early and think about implementation strategies more thoroughly.\nThe proposal review also helped me break down the project into more manageable milestones and clarify the technical specifications for each quantum system I‚Äôll be implementing."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#meeting-the-team",
    "href": "posts/Community Bonding/community-bonding.html#meeting-the-team",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "Meeting the Team",
    "text": "Meeting the Team\nThe highlight of the community bonding period was definitely my first introductory meeting with the QuTiP team on May 23rd. Meeting Alex Pitchford, Neill Lambert, and Simon Cross was both exciting and slightly nerve-wracking!\nThe team was incredibly welcoming and provided great insights into the QuTiP ecosystem. We had an in-depth discussion about the technical approach for the Hamiltonian Library, covering several key areas:\nTechnical Architecture: We discussed keeping the class hierarchy simple and clean, focusing on usability over complexity. The team emphasized the importance of identifying common patterns and similarities between different quantum models to create a coherent and intuitive API.\nResearch Foundation: There was strong agreement on the need to thoroughly research existing literature for different quantum models to ensure our implementations are both accurate and comprehensive. Starting with well-established models like the Jaynes-Cummings model and various spin models would provide a solid foundation before expanding to more complex systems.\nPortability Considerations: An interesting discussion emerged around inter-portability of the library. While Simon and Alex advocated for maximizing cross-platform compatibility, Eric had earlier suggested to them to focus only on Python implementation initially. This highlighted the balance between ambition and practical delivery that‚Äôs crucial for GSoC projects.\nProject Scope: The team helped me understand that starting with core models and seeing where the project naturally evolves would be more valuable than trying to implement everything at once. This iterative approach would allow for better testing and refinement of the library‚Äôs design.\nWhat struck me most was how collaborative and open the discussion was - they genuinely wanted to understand my vision for the project while sharing their deep expertise in quantum simulation."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#sharpening-technical-skills",
    "href": "posts/Community Bonding/community-bonding.html#sharpening-technical-skills",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "Sharpening Technical Skills",
    "text": "Sharpening Technical Skills\nKnowing that the coding phase would be intensive, I dedicated time to brushing up on essential technical skills:\nPython Proficiency: Reviewed Python concepts, particularly focusing on object-oriented design that would be crucial for building a well-structured Hamiltonian library. I dove into topics like inheritance, composition, and abstract base classes.\nGit & GitHub Workflow: Refreshed my knowledge of collaborative development practices, including branching strategies, code review processes, and best practices for open-source contributions. This proved invaluable for contributing to a project with multiple maintainers.\nTesting with pytest: Since robust testing would be crucial for a scientific computing library, I spent some time on some pytest features including parameterized tests, and testing strategies for numerical code.\nI also dedicated some time to familiarizing myself with the QuTiP ecosystem, diving into qutip-qip and working through qutip-tutorials to understand the current state of quantum simulation tools and identify where my Hamiltonian Library would fit most naturally."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#contributing-beyond-gsoc",
    "href": "posts/Community Bonding/community-bonding.html#contributing-beyond-gsoc",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "Contributing Beyond GSoC",
    "text": "Contributing Beyond GSoC\nDuring this period, I also participated in Unitary Hack 2025, having a look at other quantum information and computing libraries and openeing a few PR. This experience was valuable - it helped me understand different codebases from a design point, hoping I might find something inspiring that could be included in my project.\nWorking on some of the issues helped me refine my approach to reading documentation, understanding existing code architecture, and making improvements. These skills will be directly applicable to my work on the QuTiP Hamiltonian Library."
  },
  {
    "objectID": "posts/Community Bonding/community-bonding.html#looking-ahead",
    "href": "posts/Community Bonding/community-bonding.html#looking-ahead",
    "title": "Community Bonding Period: Setting the Foundation for Success",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nAs we transition into the coding phase, I feel excited about the journey ahead. The community bonding period has helped me with a clearer understanding of the project scope, good communication with my mentors, refreshed technical skills, and valuable experience from contributing to other projects.\nThe next phase will focus on deciding the architecture and starting work on the first set of quantum system models. Following the team‚Äôs guidance, I‚Äôll begin with the Jaynes-Cummings model and spin models, keeping the architecture simple while ensuring it‚Äôs extensible for future quantum systems.\nStay tuned for weekly updates as we dive into the exciting world of quantum Hamiltonian implementations!\n\nNext up: Setting up the development environment and deciding the foundational architecture for the Hamiltonian Library."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "",
    "text": "I‚Äôm a physicst with a passion for quantum computing and open-source software. Currently, I‚Äôm participating in Google Summer of Code 2025, working on developing a comprehensive Hamiltonian Library for QuTiP."
  },
  {
    "objectID": "about.html#hello",
    "href": "about.html#hello",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "",
    "text": "I‚Äôm a physicst with a passion for quantum computing and open-source software. Currently, I‚Äôm participating in Google Summer of Code 2025, working on developing a comprehensive Hamiltonian Library for QuTiP."
  },
  {
    "objectID": "about.html#current-work",
    "href": "about.html#current-work",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "Current Work",
    "text": "Current Work\nGoogle Summer of Code 2025 Contributor\nMay 2025 - Present\nWorking with NumFOCUS on developing a Hamiltonian Library for QuTiP (Quantum Toolbox in Python). The project aims to create a standardized, comprehensive library of quantum system Hamiltonians to reduce redundant work in the quantum computing research community.\nKey contributions: - Developing ready-to-use implementations of common quantum systems - Creating standardized APIs for consistency across different models - Implementing JSON serialization for cross-platform compatibility - Adding LaTeX representation capabilities for clear documentation"
  },
  {
    "objectID": "about.html#interests",
    "href": "about.html#interests",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "Interests",
    "text": "Interests\n\nQuantum Computing: Simulation, algorithms, and practical applications\nOpen Source: Contributing to scientific computing libraries\nPython Development: Scientific computing, data analysis, and automation\nResearch: Quantum mechanics, numerical methods, and computational physics"
  },
  {
    "objectID": "about.html#technical-skills",
    "href": "about.html#technical-skills",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "Technical Skills",
    "text": "Technical Skills\n\nLanguages: Python, Julia\nQuantum Computing: QuTiP, Qiskit, quantum algorithms\nTools: Git, GitHub, Jupyter, LaTeX,\nWeb Development: Quarto"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "about.html#contact",
    "href": "about.html#contact",
    "title": "Google Summer of Code 2025 | QuTiP | NumFOCUS",
    "section": "Contact",
    "text": "Contact\nFeel free to reach out if you‚Äôd like to discuss quantum computing, open source projects, or potential collaborations.\n\nEmail: vanshajbindal98@gmail.com\nGitHub: github.com/Vanshaj0429\nLinkedIn: linkedin.com/in/vanshaj-bindal"
  },
  {
    "objectID": "posts/Week4/week4_blog.html",
    "href": "posts/Week4/week4_blog.html",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "",
    "text": "After a brief pause for the summer school in Paris during Week 3, Week 4 has been all about getting hands dirty with actual code implementation. This week marked the transition from theoretical planning to concrete software development, with the first working implementation of the Jaynes-Cummings model taking shape."
  },
  {
    "objectID": "posts/Week4/week4_blog.html#design-template-dilemma",
    "href": "posts/Week4/week4_blog.html#design-template-dilemma",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Design Template Dilemma",
    "text": "Design Template Dilemma\nOne of the main challenges this week was settling on how to structure the code. I found myself wrestling with a fundamental question: should we use a modular approach with separate functions for different components, or a unified function that returns everything at once?\nThis led me to develop two different iterations of the JC model implementation, each representing a different philosophy:\n\nIteration 1: Modular Design Pattern\nThe first approach breaks down the quantum system into distinct, reusable components:\ndef build_jc_operators(n_cavity: int)\ndef build_jc_hamiltonian(n_cavity, omega_c, omega_a, g, rotating_wave, operators)\ndef build_jc_collapse_operators(operators, cavity_decay, atomic_decay, atomic_dephasing, thermal_noise)\ndef jc_latex_representation(rotating_wave)\nThis modular approach offers several advantages:\n\nFlexibility: Users can call individual functions if they only need specific components\nClarity: Each function has a single, well defined responsibility\nDebugging: Easier to test and debug individual components\n\n\n\nIteration 2: Unified Function Design\nThe second approach consolidates everything into a single function:\ndef jaynes_cummings_model(n_cavity, omega_c, omega_a, g, rotating_wave,\n                        cavity_decay, atomic_decay, atomic_dephasing, thermal_noise):\n   # Returns: operators, hamiltonian, c_ops, latex\nThis unified approach provides:\n\nSimplicity: One function call gets you everything\nConsistency: All components are guaranteed to be compatible\nConvenience: Perfect for users who want the complete system\nLess overhead: No need to pass operators between functions"
  },
  {
    "objectID": "posts/Week4/week4_blog.html#implementation-details-and-design-choices",
    "href": "posts/Week4/week4_blog.html#implementation-details-and-design-choices",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Implementation Details and Design Choices",
    "text": "Implementation Details and Design Choices\nMost of my time this week was spent ensuring the correctness of the quantum mechanical implementations across both design patterns. Here are the key aspects I focused on:\n\nOperator Construction\nThe fundamental operators form the building blocks of any quantum system. For the JC model, I implemented:\n\nCavity operators: Photon creation/annihilation (a, a_dag) and number operator (n_c)\nAtomic operators: Pauli matrices and raising/lowering operators (sigma_plus, sigma_minus, sigma_z, sigma_x, sigma_y)\n\nEach operator is properly tensorized to work in the combined cavity-atom Hilbert space, which was crucial to get right.\n\n\nParameter Choices and Flexibility\nAfter considerable thought, I settled on the following parameter set for the JC model:\nSystem Parameters:\n\nn_cavity: Hilbert space truncation (default: 10)\nomega_c: Cavity frequency (default: 1.0)\nomega_a: Atomic frequency (default: 1.0)\ng: Coupling strength (default: 0.1)\nrotating_wave: Boolean flag for RWA vs full Rabi model (default: True)\n\nDissipation Parameters:\n\ncavity_decay: Photon leakage rate Œ∫ (default: 0.0)\natomic_decay: Spontaneous emission rate Œ≥ (default: 0.0)\natomic_dephasing: Pure dephasing rate Œ≥_œÜ (default: 0.0)\nthermal_noise: Tuple (n_th, kappa) for thermal effects (default: None)\n\nThese defaults provide sensible starting points while allowing full customization for specific research needs.\n\n\nThermal Noise Implementation\nOne interesting aspect was implementing thermal noise correctly. When the cavity is coupled to a thermal bath at finite temperature, we need both absorption and emission processes:\n\nThermal absorption: Rate ‚àù Œ∫ √ó n_th (creating photons)\nStimulated emission: Rate ‚àù Œ∫ √ó (n_th + 1) (destroying photons)\n\nThis required careful handling of the thermal photon number n_th and the cavity decay rate.\n\n\nThe Driving Term Decision\nAn important design choice was how to handle external driving fields. Rather than building driving terms directly into our functions, I decided to keep them external. This means users can add driving terms right before when setting up their time evolution:\n# Our function provides the base system\nops, H0, c_ops, latex = jaynes_cummings_model(...)\n\n# Users add driving externally  \nH_drive = lambda t, args: driving_amplitude * (ops['a'] * np.exp(-1j * drive_freq * t) + ops['a_dag'] * np.exp(1j * drive_freq * t))\nH_total = H0 + H_drive\nThis approach maintains simplicity in our core functions while providing maximum flexibility for time-dependent problems."
  },
  {
    "objectID": "posts/Week4/week4_blog.html#validation-and-testing",
    "href": "posts/Week4/week4_blog.html#validation-and-testing",
    "title": "Week 4: First Code Implementation - Design Decisions and JC Model Development",
    "section": "Validation and Testing",
    "text": "Validation and Testing\nMuch of the week was spent on validation - ensuring that:\n\nOperators have the correct dimensions and commutation relations\nThe Hamiltonian produces expected energy eigenvalues for simple cases\nCollapse operators are properly normalized with their rates\nThe rotating wave approximation flag correctly switches between JC and Rabi models"
  },
  {
    "objectID": "posts/Week4/week4_blog.html#reflections-on-design-philosophy",
    "href": "posts/Week4/week4_blog.html#reflections-on-design-philosophy",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Reflections on Design Philosophy",
    "text": "Reflections on Design Philosophy\nWorking through both implementation approaches this week has been enlightening. The modular design feels more ‚Äúsoftware engineering appropriate‚Äù, it‚Äôs extensible, testable, and follows good separation of concerns. However, the unified approach might be more user friendly for researchers who just want to get a complete quantum system quickly.\nThis tension between software engineering best practices and user convenience is something we‚Äôll likely revisit as we implement more quantum models. The good news is that both approaches are viable, and we can potentially support both patterns depending on user needs."
  },
  {
    "objectID": "posts/Week4/week4_blog.html#looking-ahead",
    "href": "posts/Week4/week4_blog.html#looking-ahead",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nWeek 5 will focus on:\n\nGetting team feedback on both implementation approaches\nRefining the chosen design pattern based on mentor input\nBeginning implementation of the Rabi model (non-RWA version)\nAdding comprehensive documentation and examples\nTesting integration with QuTiP‚Äôs master equation solvers\n\nThe foundation is now in place, and having working code makes everything feel much more concrete. The next phase will be about refinement, expansion, and ensuring our design choices scale well to other quantum systems."
  },
  {
    "objectID": "posts/Week-4/week4.html",
    "href": "posts/Week-4/week4.html",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "",
    "text": "After a brief pause for the summer school in Paris during Week 3, Week 4 has been all about getting hands dirty with actual code implementation. This week marked the transition from theoretical planning to concrete software development, with the first working implementation of the Jaynes-Cummings model taking shape."
  },
  {
    "objectID": "posts/Week-4/week4.html#design-template-dilemma",
    "href": "posts/Week-4/week4.html#design-template-dilemma",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Design Template Dilemma",
    "text": "Design Template Dilemma\nOne of the main challenges this week was settling on how to structure the code. I found myself wrestling with a fundamental question: should we use a modular approach with separate functions for different components, or a unified function that returns everything at once?\nThis led me to develop two different iterations of the JC model implementation, each representing a different philosophy:\n\nIteration 1: Modular Design Pattern\nThe first approach breaks down the quantum system into distinct, reusable components:\ndef build_jc_operators(n_cavity: int)\ndef build_jc_hamiltonian(n_cavity, omega_c, omega_a, g, rotating_wave, operators)\ndef build_jc_collapse_operators(operators, cavity_decay, atomic_decay, atomic_dephasing, thermal_noise)\ndef jc_latex_representation(rotating_wave)\nThis modular approach offers several advantages:\n\nFlexibility: Users can call individual functions if they only need specific components\nClarity: Each function has a single, well defined responsibility\nDebugging: Easier to test and debug individual components\n\n\n\nIteration 2: Unified Function Design\nThe second approach consolidates everything into a single function:\ndef jaynes_cummings_model(n_cavity, omega_c, omega_a, g, rotating_wave,\n                        cavity_decay, atomic_decay, atomic_dephasing, thermal_noise):\n   # Returns: operators, hamiltonian, c_ops, latex\nThis unified approach provides:\n\nSimplicity: One function call gets you everything\nConsistency: All components are guaranteed to be compatible\nConvenience: Perfect for users who want the complete system\nLess overhead: No need to pass operators between functions"
  },
  {
    "objectID": "posts/Week-4/week4.html#implementation-details-and-design-choices",
    "href": "posts/Week-4/week4.html#implementation-details-and-design-choices",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Implementation Details and Design Choices",
    "text": "Implementation Details and Design Choices\nMost of my time this week was spent ensuring the correctness of the quantum mechanical implementations across both design patterns. Here are the key aspects I focused on:\n\nOperator Construction\nThe fundamental operators form the building blocks of any quantum system. For the JC model, I implemented:\n\nCavity operators: Photon creation/annihilation (a, a_dag) and number operator (n_c)\nAtomic operators: Pauli matrices and raising/lowering operators (sigma_plus, sigma_minus, sigma_z, sigma_x, sigma_y)\n\nEach operator is properly tensorized to work in the combined cavity-atom Hilbert space, which was crucial to get right.\n\n\nParameter Choices and Flexibility\nAfter considerable thought, I settled on the following parameter set for the JC model:\nSystem Parameters:\n\nn_cavity: Hilbert space truncation (default: 10)\nomega_c: Cavity frequency (default: 1.0)\nomega_a: Atomic frequency (default: 1.0)\ng: Coupling strength (default: 0.1)\nrotating_wave: Boolean flag for RWA vs full Rabi model (default: True)\n\nDissipation Parameters:\n\ncavity_decay: Photon leakage rate Œ∫ (default: 0.0)\natomic_decay: Spontaneous emission rate Œ≥ (default: 0.0)\natomic_dephasing: Pure dephasing rate Œ≥_œÜ (default: 0.0)\nthermal_noise: Tuple (n_th, kappa) for thermal effects (default: None)\n\nThese defaults provide sensible starting points while allowing full customization for specific research needs.\n\n\nThermal Noise Implementation\nOne interesting aspect was implementing thermal noise correctly. When the cavity is coupled to a thermal bath at finite temperature, we need both absorption and emission processes:\n\nThermal absorption: Rate ‚àù Œ∫ √ó n_th (creating photons)\nStimulated emission: Rate ‚àù Œ∫ √ó (n_th + 1) (destroying photons)\n\nThis required careful handling of the thermal photon number n_th and the cavity decay rate.\n\n\nThe Driving Term Decision\nAn important design choice was how to handle external driving fields. Rather than building driving terms directly into our functions, I decided to keep them external. This means users can add driving terms right before when setting up their time evolution:\n# Our function provides the base system\nops, H0, c_ops, latex = jaynes_cummings_model(...)\n\n# Users add driving externally  \nH_drive = lambda t, args: driving_amplitude * (ops['a'] * np.exp(-1j * drive_freq * t) + ops['a_dag'] * np.exp(1j * drive_freq * t))\nH_total = H0 + H_drive\nThis approach maintains simplicity in our core functions while providing maximum flexibility for time-dependent problems."
  },
  {
    "objectID": "posts/Week-4/week4.html#reflections-on-design-philosophy",
    "href": "posts/Week-4/week4.html#reflections-on-design-philosophy",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Reflections on Design Philosophy",
    "text": "Reflections on Design Philosophy\nWorking through both implementation approaches this week has been enlightening. The modular design feels more ‚Äúsoftware engineering appropriate‚Äù, it‚Äôs extensible, testable, and follows good separation of concerns. However, the unified approach might be more user friendly for researchers who just want to get a complete quantum system quickly.\nThis tension between software engineering best practices and user convenience is something we‚Äôll likely revisit as we implement more quantum models. The good news is that both approaches are viable, and we can potentially support both patterns depending on user needs."
  },
  {
    "objectID": "posts/Week-4/week4.html#looking-ahead",
    "href": "posts/Week-4/week4.html#looking-ahead",
    "title": "Week 4: First Code Implementation - Code Structure and Development",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nWeek 5 will focus on:\n\nGetting team feedback on both implementation approaches\nRefining the chosen design pattern based on mentor input\nBeginning implementation of the Rabi model (non-RWA version)\nAdding comprehensive documentation and examples\nTesting integration with QuTiP‚Äôs master equation solvers\n\nThe foundation is now in place, and having working code makes everything feel much more concrete. The next phase will be about refinement, expansion, and ensuring our design choices scale well to other quantum systems."
  }
]